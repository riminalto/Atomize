# Atomize

**告别决策疲劳，专注当下的命令行任务执行器。**

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Python Version](https://img.shields.io/badge/python-3.6%2B-blue.svg)](https://www.python.org/)

你是否也曾面对长长的待办事项列表，反复纠结“接下来该做什么？”，最终在无尽的决策中耗尽心力？

Atomize 并非又一个 To-do List 工具，它是一个**决策辅助与执行引擎**。你只需在每天开始时，使用一种极其简单的语法规划好任务的“结构”与“依赖”，剩下的“选择”就交给 Atomize。它会在你设定的框架内，随机推送下一个可执行任务，让你从“选择的重负”中解脱，只需专注于“完成”。

---

## 核心特性

*   **简洁强大的 DSL (领域特定语言)**: 使用 `,` `()` `[]` `-` 等几个简单符号，就能规划出复杂的并行、串行、嵌套任务流。
*   **结构化随机调度**: 核心亮点！在所有当前可执行的任务中随机选择，既保证了任务推进的逻辑性，又带来了“开盲盒”般的新鲜感，有效对抗任务启动困难。
*   **清晰的上下文路径**: 执行子任务时，会清晰展示其所属的父任务层级 (如 `西方社会学 > 齐美尔 > 文化理论新学`)，让你时刻明确当前任务的意义和归属。
*   **动态任务管理**: 在执行过程中，可以随时对当前任务进行拆分 (`s`)、添加新任务 (`a`)、编辑 (`e`) 或取消 (`c`)，灵活应对突发奇想和计划变更。
*   **末尾任务队列**: 通过 `-` 符号将“收尾”、“整理”等低能耗任务置于末尾，确保你在精力最充沛的时候，优先处理最重要的核心任务。
*   **零依赖，纯文本存储**: 纯 Python 实现，无需任何外部库。所有数据都保存在本地的 `.json` 和 `.csv` 文件中，安全、透明、易于迁移。

## 设计哲学

Atomize 的设计深受认知科学与心理学启发，旨在解决现代知识工作者面临的核心痛点：

1.  **对抗决策疲劳 (Decision Fatigue)**
    *   **问题**: “选择”本身是一种心力消耗。在多个任务间犹豫不决，比执行任务本身更累。
    *   **Atomize 方案**: 将决策权部分让渡给程序。你负责“规划”（一次性高阶决策），程序负责“选择”（即时低阶决策）。这让你能将宝贵的意志力全部用于“执行”。

2.  **原子化与心流 (Atomization & Flow)**
    *   **问题**: 巨大的、模糊的任务（如“写报告”）会持续占据心智带宽，引发焦虑（蔡格尼克记忆效应）。
    *   **Atomize 方案**: 强制你在规划时，通过 DSL 将大任务分解为一个个具体的、“一次就能完成”的原子任务。每完成一个，你都会获得即时反馈和多巴胺奖励，更容易进入沉浸式的“心流”状态。

3.  **区分深浅工作 (Deep vs. Shallow Work)**
    *   **问题**: 琐碎的浅度工作常常在黄金时间段打断需要高度专注的深度工作。
    *   **Atomize 方案**: “末尾任务”机制是一个天然的过滤器。它让你自然地将“写代码”、“写论文”等深度工作放在常规任务池，把“回复邮件”、“整理文件”等浅度工作扔进末尾任务池，从而保护你最高效的专注时段。

## 快速开始

### 1. 安装

无需复杂安装。只需克隆本仓库：

```bash
git clone https://github.com/你的用户名/atomize.git
cd atomize
```

### 2. 运行

直接使用 Python 运行 `run.py` 文件：

```bash
python run.py
```

### 3. 使用流程

1.  程序启动后，显示主菜单。输入 `1` 开始新一天的规划。
2.  在 `>` 提示符后，输入你的任务规划字符串。例如：

    ```
    社会统计(第四章学完-第四章课后习题-制卡),英语(阅读[做题-分析],墨墨背单词),-整理桌面,-回复邮件
    ```

3.  回车后，Atomize 会解析任务并开始执行。它会为你呈现第一个随机选择的可执行任务。
4.  根据提示进行操作：
    *   `d` (done): 完成当前任务。
    *   `p` (postpone): 推迟当前任务（它会在稍后再次出现）。
    *   `q` (quit): 暂停执行，返回主菜单。
    *   `s` (split): 将当前任务拆分为更小的子任务。
    *   `a` (add): 在当前任务后添加一个新任务。
    *   `e` (edit): 修改当前任务的名称。
    *   `c` (cancel): 永久取消当前任务。

5.  完成所有任务后，程序会自动结束。你也可以在主菜单选择 `3` 查看今日总结，或 `2` 继续上次未完成的任务。

## DSL 语法速查表

| 规则 | 语法 | 解释 |
| :--- | :--- | :--- |
| **并行任务** | `任务A, 任务B` | A 和 B 没有固定顺序，系统会随机选择一个。 |
| **串行任务** | `任务A-任务B` | 必须先完成 A，B 才会成为可选项。 |
| **父子任务/分组**| `项目A(子任务1, 子任务2)` | `项目A` 是一个上下文分类，不可执行。子任务 1 和 2 是可执行的。`()` 和 `[]` 功能相同，可用于嵌套。 |
| **末尾任务** | `-任务C`, `-项目B(...)` | 标记为末尾任务。只有在所有常规任务都完成后，系统才会开始处理它们。 |
| **组合使用** | `工作(项目A[规划-开发], 项目B), -学习` | 强大的组合能力，可以构建任何你需要的工作流。 |

## 未来计划

*   [ ] **增强统计报告**: 提供周度、月度总结，并进行可视化展示。
*   [ ] **任务标签与过滤**: 为任务添加 `#tag`，并能在总结中按标签筛选。
*   [ ] **更丰富的配置**: 允许用户自定义颜色、专注点数等。
*   [ ] **TUI 界面优化**: 考虑使用 `rich` 或 `curses` 库，提供更现代化的终端界面体验。

## 贡献

欢迎任何形式的贡献！无论是提交 Issue、发起 Pull Request，还是分享你的使用体验和建议。

1.  Fork 本仓库
2.  创建你的 Feature Branch (`git checkout -b feature/AmazingFeature`)
3.  提交你的更改 (`git commit -m 'Add some AmazingFeature'`)
4.  推送到你的 Branch (`git push origin feature/AmazingFeature`)
5.  发起 Pull Request

## 许可证

本项目使用 MIT 许可证。详情请见 `LICENSE` 文件。

---

**保持专注，一次一事。**
**Stay focused. One task at a time.**